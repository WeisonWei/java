# MySQL

## 服务器&客户端
`MySQL`服务器进程的默认名称为`mysqld` 
`MySQL`客户端进程的默认名称为`mysql`
## 服务端启动&客户端登陆
```shell script
#启动
mysql.server` --间接调用--> `mysqld_safe` --间接调用--> `mysqld` --指定--> `start`参数
#连接
mysql -hlocalhost -uroot -p123456
```

## 客户端&服务器连接
`MySQL`采用`TCP`作为服务器和客户端之间的网络通信协议。

```shell script
#指定端口启动
mysqld -P3307
#连接
mysql -h127.0.0.1 -uroot -P3307 -p

```
- Unix域套接字文件
如果我们的服务器进程和客户端进程都运行在同一台操作系统为类`Unix`的机器上的话，我们可以使用`Unix域套接字文件`来进行进程间通信。
如果我们在启动客户端程序的时候指定的主机名为`localhost`，或者指定了`--protocal=socket`的启动参数，
那服务器程序和客户端程序之间就可以通过`Unix`域套接字文件来进行通信了。

`MySQL`服务器程序默认监听的`Unix`域套接字文件路径为`/tmp/mysql.sock`，客户端程序也默认连接到这个`Unix`域套接字文件。
如果我们想改变这个默认路径，可以在启动服务器程序时指定`socket`参数，就像这样：
```
mysqld --socket=/tmp/a.txt
```
这样服务器启动后便会监听`/tmp/a.txt`。
在服务器改变了默认的`UNIX`域套接字文件后，如果客户端程序想通过`UNIX`域套接字文件进行通信的话，也需要显式的指定连接到的`UNIX`域套接字文件路径，就像这样：
```
mysql -hlocalhost -uroot --socket=/tmp/a.txt -p
```
这样该客户端进程和服务器进程就可以通过路径为`/tmp/a.txt`的`Unix`域套接字文件进行通信了。

## 服务端
服务器程序处理来自客户端的查询请求大致需要经过三个部分，
分别是`连接管理`、`解析与优化`、`存储引擎`
![image_1c8d26fmg1af0ms81cpc7gm8lv39.png-97.9kB](https://user-gold-cdn.xitu.io/2018/12/28/167f4c7b99f87e1c?w=842&h=559&f=png&s=100231)

### 连接管理

客户端进程可以采用我们上边介绍的`TCP/IP`、`命名管道或共享内存`、`Unix域套接字`这几种方式之一来与服务器进程建立连接，
每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，
当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，
在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。
这样就起到了不频繁创建和销毁线程的效果，从而节省开销。
### 解析与优化
`MySQL`服务器已经获得了文本形式的请求，接着 还要经过九九八十一难的处理，其中的几个比较重要的部分分别是`查询缓存`、`语法解析`和`查询优化`。

### 查询缓存
`9+8×16-3×2×17`的值是多少，去算一下得到了结果`35`，如果我再问你一遍`9+8×16-3×2×17`的值是多少，你还用再傻呵呵的算一遍么？
我们刚刚已经算过了，直接说答案就好了。

查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，
如 mysql 、information\_schema、 performance\_schema 数据库中的表，那这个请求就不会被缓存
MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，
如对该表使用了`INSERT`、 `UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或 `DROP DATABASE`语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！

### 语法解析
因为客户端程序发送过来的请求只是一段文本而已，所以`MySQL`服务器程序首先要对这段文本做分析，判断请求的语法是否正确，
然后从文本中将要查询的表、各种查询条件都提取出来放到`MySQL`服务器内部使用的一些数据结构上来。

### 查询优化
`MySQL`的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接吧啦吧啦的一堆东西。
优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用`EXPLAIN`语句来查看某个语句的执行计划，关于查询优化这部分的详细内容我们后边会仔细唠叨，现在你只需要知道在`MySQL`服务器程序处理请求的过程中有这么一个步骤就好了。

### 存储引擎
到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，`MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里。
我们知道`表`是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，
这都是`存储引擎`负责的事情。
为了实现不同的功能，`MySQL`提供了各式各样的`存储引擎`，不同`存储引擎`管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

MySQL支持非常多种存储引擎，我这先列举一些：  
存储引擎 	描述  
ARCHIVE 	用于数据存档（行被插入后不能再修改）  
BLACKHOLE 	丢弃写操作，读操作会返回空内容  
CSV 	在存储数据时，以逗号分隔各个数据项  
FEDERATED 	用来访问远程表  
InnoDB 	具备外键支持功能的事务存储引擎  
MEMORY 	置于内存的表  
MERGE 	用来管理多个MyISAM表构成的表集合  
MyISAM 	主要的非事务处理存储引擎  
NDB 	MySQL集群专用存储引擎  

其实我们最常用的就是InnoDB和MyISAM，有时会提一下Memory。
其中InnoDB是MySQL默认的存储引擎，我们之后会详细唠叨这个存储引擎的各种功能，现在先看一下一些存储引擎对于某些功能的支持情况：


查看当前服务器程序支持的存储引擎：
```shell script
SHOW ENGINES;
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;
ALTER TABLE engine_demo_table ENGINE = InnoDB;

SHOW CREATE TABLE engine_demo_table


```

对于16KB的页来说，连续的64个页就是一个区，一个区默认占用1MB空间大小；
不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。


[深入理解 MySQL 底层实现](https://gitbook.cn/gitchat/activity/5a07c4266a4b0d78856826ea)
[MySQL 索引与优化](https://gitbook.cn/books/5c92fd312cc79178471b68db/index.html)
[138 张图带你 MySQL 入门](https://gitbook.cn/books/5eef6f0335d2480b101d7552/index.html)
[47 张图带你 MySQL 进阶](https://gitbook.cn/gitchat/activity/5f1a8d30a50beb3089673b7a)
[MySQL 高级教程](https://gitbook.cn/gitchat/activity/5efdd8ae44dfac09f99610bb)
